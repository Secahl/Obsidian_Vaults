## Exploiting blind XXE by repurposing a local DTD

The preceding technique works fine with an external DTD, but it won't normally work with an internal DTD that is fully specified within the `DOCTYPE` element.  
This is because the technique involves using an XML parameter entity within the definition of another parameter entity (appending/redefining new parameter entities within the already defined XML parameter entity). 
Per the XML specification, this is permitted in external DTDs but not in internal DTDs. (Some parsers might tolerate it, but many do not.)  
  
**So what about blind XXE vulnerabilities when out-of-band interactions are blocked?**  
  
You can't exfiltrate data via an out-of-band connection, and you can't load an external DTD from a remote server.  
In this situation, it might still be possible to trigger error messages containing sensitive data, due to a loophole in the XML language specification. 
>_If a document's DTD uses a hybrid of internal and external DTD declarations, then the internal DTD can redefine entities that are declared in the external DTD._ 

When this happens, the restriction on using an XML parameter entity within the definition of another parameter entity is relaxed.  
  
This means that an attacker can employ the [[C > Exploiting blind XXE to retrieve data via error messages#Exploiting blind XXE to retrieve data via error messages| Error based XXE]] technique from within an internal DTD, provided the XML parameter entity that they use is redefining an existing entity(pre-defined entity) that was already declared(pre-defined) within an external DTD.  

_Of course, if out-of-band connections are blocked, then the external DTD cannot be loaded from a remote location. Instead, it needs to be an external DTD file that is local to the application server. Essentially, the attack involves invoking a DTD file that happens to exist on the local filesystem and repurposing it to redefine an existing entity in a way that triggers a parsing error containing sensitive data._ This technique was pioneered by Arseniy Sharoglazov, and ranked #7 in our [top 10 web hacking techniques of 2018](https://portswigger.net/blog/top-10-web-hacking-techniques-of-2018#7).  
  
>For example, suppose there is a DTD file on the server filesystem at the location `/usr/local/app/schema.dtd`, and this DTD file already contains a pre-defined entities amoing which one is called `custom_entity`.  
>>An attacker can trigger an XML parsing error message containing the contents of the `/etc/passwd` file by submitting a hybrid DTD like the following :-  
```xml
<!DOCTYPE foo [  
                 <!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">  
                 <!ENTITY % custom_entity '  
                     <!ENTITY &#x25; file SYSTEM "file:///etc/passwd">  
                     <!ENTITY &#x25; eval "<!ENTITY  &#x26;#x25; error SYSTEM  &#x27;file:///nonexistent/&#x25;file;&#x27;>">  
                     &#x25;eval;  
                     &#x25;error;  
                 '>  
                 %local_dtd;  
             ]>       
```
  
  
  
This DTD carries out the following steps:  
  
>• Defines an XML parameter entity called `local_dtd`, containing the contents of the external DTD file that exists on the server filesystem.  
• Redefines the XML parameter entity called `custom_entity`, which is already defined in the external DTD file. The entity is redefined as containing the [[C > Exploiting blind XXE to retrieve data via error messages#Exploiting blind XXE to retrieve data via error messages| error-based XXE exploit]] that was already described, for triggering an error message containing the contents of the `/etc/passwd` file.  
• Uses the `local_dtd` entity, so that the external DTD is interpreted, including the redefined value of the `custom_entity` entity. This results in the desired error message.


Linked Nodes :

[[Locating an existing DTD file to repurpose]]